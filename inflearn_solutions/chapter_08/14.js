// 1부터 N까지 번호가 적힌 구슬이 있습니다.이중 M개를 뽑는 방법의 수를 출력하는 프로그램을 작성하세요.

// 문제 이해를 잘해야된다. [3, 6, 9]가 있으면, 
// 중복 순열 :   [ [ 3, 3 ], [ 3, 6 ], [ 3, 9 ], [ 6, 3 ], [ 6, 6 ], [ 6, 9 ], [ 9, 3 ], [ 9, 6 ], [ 9, 9 ] ]
// 순열     :   [ [ 3, 6 ], [ 3, 9 ], [ 6, 3 ], [ 6, 9 ], [ 9, 3 ], [ 9, 6 ] ]
// 이 문제는 :   [ [3,6], [3,9], [6,9] ]

// 접근법: availale한 가지의 수를 다음 L로 뻗어나갈 때 한개씩 줄여버리는 거임

function solution (N, m) {
    let answer = [];
    let tmp = Array.from({length:m}, ()=>0);
    function dfsR(L, s) { // string 가지. Available한 가지의 수. 여기서는 자연수 (N)1,2,3,4이렇게 4가지
        if (L===m) {
            answer.push(tmp.slice()); // 지정석 tmp배열에 담긴 경우의 수들을 answer배열로 push. 그리고 뒤에 slice해줘서 깊은 복사로 만들어준다
        } else {
            for (let i=s; i<N+1; i++) { // 이진트리가 아니라 4진 트리다. 그러니 for문을 돌리자. Available한 가지가 지금 총 4개다. 1번 구슬, 2번 구슬, 3번 구슬, 4번 구슬. 그리고 dfsR(0,1) 1번 가지부터 시작했으니 (i=1; i<N+1; i++) 이거랑 같은거다 지금
                tmp[L]=i; // 처음 for문을 돌면 지정석 두 자리 중 tmp[0]의 자리에 i인 (N)1이 들어가겠지 
                dfsR(L+1, 1+i); // 그리고 다음 배열로 넘어왔지. 'dfsR(0,1)'에서 L, s 둘 다 1씩 증가해서 'dfsR(2,2)'가 된거다. 아무튼 for문을 
            }
        }
    }
    dfsR(0,1); // 왜 s를 1부터 시작하는지 , 그리고 윗줄에 dfsR(L+1, 1+i) 왜 1+i 인지 모르겠다 . 왜i만큼 더해주는거지?
    return answer;
}
console.log(solution(4, 2)); // [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]





